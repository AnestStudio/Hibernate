# Hibernate Native SQL Queries

<br />

Trong Hibernate, HQL hoặc Criteria Query cho phép chúng ta thực hiện hầu hết mọi truy vấn SQL mong muốn. Tuy nhiên, đôi khi về câu lệnh SQL được tạo ra bởi Hibernate chậm hoặc cần viết câu lệnh phức tạp và thích tạo câu lệnh SQL (SQL gốc) của riêng mình hơn. Với Hibernate cho chúng ta sử dụng Native SQL để thao tác với cơ sở dữ liệu, bao gồm các stored procedures, và tất cả các thao tác create, update, delete và select.

Bảng dữ liệu demo sẽ sử dụng trong bài:
<table>
  <thead>
    <tr>
      <th width="112px">user_id</th>
      <th width="150px">username</th>
      <th width="150px">password</th>
      <th width="300px">created_at</th>
      <th width="300px">modified_at</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">1</td>
      <td align="right">AnhDT</td>
      <td align="right">12345678</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
    </tr>
    <tr>
      <td align="center">2</td>
      <td align="right">MinhTH</td>
      <td align="right">12345678</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
    </tr>
    <tr>
      <td align="center">3</td>
      <td align="right">HoaTTH</td>
      <td align="right">12345678</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
    </tr>
  </tbody>
</table>

<br />

## 1. Defining and executing a native query

### 1.1. Creating a native query

Việc thực thi các truy vấn SQL gốc được kiểm soát thông qua `NativeQuery` interface, interface này có được bằng cách gọi `Session.createNativeQuery()`.

<br />

### 1.2. Scalar queries

Truy vấn SQL cơ bản nhất là lấy danh sách các giá trị vô hướng (column) từ một hoặc nhiều bảng.

Ví dụ lấy tất cả __column__ từ bảng __User__
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<Object[]> users = session.createNativeQuery("SELECT * FROM [User]", Object[].class).getResultList();
    for (Object[] u : users) {
        System.out.println(Arrays.toString(u));
    }

    transaction.commit();
}
```

Chúng ta có thể sử dụng phương thức `list()` để nhận về kết quả tương tự như `getResultList()`.

Output
```java
[1, AnhDT, 12345678, 2024-04-12 02:26:59.66, 2024-04-12 02:26:59.66]
[2, MinhTH, 12345678, 2024-04-12 02:26:59.66, 2024-04-12 02:26:59.66]
[3, HoaTTH, 12345678, 2024-04-12 02:26:59.66, 2024-04-12 02:26:59.66]
```

SQL
```sql
[Hibernate] SELECT * FROM [User]
```

<br />

Ví dụ chỉ lấy column `username` và `password` từ bảng __User__
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<Object[]> users = session.createNativeQuery("SELECT username, password FROM [User]", Object[].class)
            .getResultList();
    for (Object[] u : users) {
        System.out.println(Arrays.toString(u));
    }

    transaction.commit();
}
```

Output
```java
[AnhDT, 12345678]
[MinhTH, 12345678]
[HoaTTH, 12345678]
```

SQL
```sql
[Hibernate] SELECT username, password FROM [User]
```

<br />

### 1.3. Create named native queries

Chúng ta có thể sử dụng `@NamedNativeQuery()` annotation để đặt tên cho câu native query.

__User.java__
```java
@NamedNativeQuery(
    name="FindUsers",
    query="SELECT * FROM [user]"
)
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

Sử dụng tên đã đặt cho câu native query thông qua phương thức `createNamedQuery()` như sau:
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<Object[]> users = session.createNamedQuery("FindUsers", Object[].class).getResultList();
    for (Object[] u : users) {
        System.out.println(Arrays.toString(u));
    }

    transaction.commit();
}
```

<br />

Từ JPA 2.2 và Hibernate 5, chúng ta có thể lặp lại `@NamedNativeQuery` annotation để đặt tên cho nhiều câu native query.
```java
@NamedNativeQuery(
    name="FindUsers",
    query="SELECT * FROM [user]"
)
@NamedNativeQuery(
    name="FindUserByUsernameAndPassword",
    query="SELECT username, password FROM [user]"
)
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

Nếu bạn đang sử dụng phiên bản JPA hoặc Hibernate cũ hơn, bạn cần phải khai báo nó bên trong `@NamedNativeQueries` annotation.
```java
@NamedNativeQueries({
    @NamedNativeQuery(
        name="FindUsers",
        query="SELECT * FROM [user]"
    ),
    @NamedNativeQuery(
        name="FindUserByUsernameAndPassword",
        query="SELECT username, password FROM [user]"
    )
})
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

<br />

### 1.4. Parameter binding

Chúng ta có thể và nên sử dụng các liên kết tham số cho các tham số truy vấn của câu native query thay vì đặt các giá trị trực tiếp vào query String.

Giống như trong JDBC, chúng ta có thể sử dụng ký tự `?` để tham chiếu đến vị trí các tham số trong câu native query và việc đánh số của chúng bắt đầu từ __1__. 
```java
SELECT * FROM [User] WHERE user_id = ?
```

Sau đó chúng ta cần sử dụng phương thức `setParameter(int var1, Object var2)` để gán giá trị cho các tham số trong câu query.
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    NativeQuery<Object> query = session.createNativeQuery("SELECT * FROM [User] WHERE user_id = ?", Object.class);
    Object[] objects = (Object[]) query.setParameter(1, 1).uniqueResult();
    System.out.println(Arrays.toString(objects));

    transaction.commit();
}
```

<br />

Hibernate cũng hỗ trợ các liên kết tham số được đặt tên cho các native queries, điều này không được xác định bởi đặc tả và có thể không khả dụng đối với các triển khai JPA khác.

Bằng cách sử dụng các liên kết tham số được đặt tên, bạn xác định tên cho từng tham số và cung cấp tên đó cho phương thức `setParameter(String var1, Object var2)` để liên kết một giá trị với tham số đó. Tên có phân biệt chữ hoa chữ thường và bạn cần thêm ký hiệu `:` làm tiền tố.

Ví dụ
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    NativeQuery<Object> query = session.createNativeQuery("SELECT * FROM [User] WHERE user_id = :id", Object.class);
    Object[] objects = (Object[]) query.setParameter("id", 1).uniqueResult();
    System.out.println(Arrays.toString(objects));

    transaction.commit();
}
```

Output
```java
[1, AnhDT, 12345678, 2024-04-12 02:26:59.66, 2024-04-12 02:26:59.66]
```

SQL
```sql
[Hibernate] SELECT * FROM [User] WHERE user_id = ?
```

<br />

## 2. Result handling

Như bạn đã thấy trong các đoạn mã trước, truy vấn gốc của bạn trả về __Object[]__ hoặc __List of Object[]__. Nếu bạn muốn truy xuất kết quả truy vấn của mình dưới dạng cấu trúc dữ liệu khác, bạn cần cung cấp thêm thông tin ánh xạ. Có 3 lựa chọn thường được sử dụng:

- Ánh xạ từng bản ghi trong kết quả truy vấn tới managed entity bằng cách sử dụng entity’s mapping.
- Sử dụng chú thích `@SqlResultSetMapping` của JPA để ánh xạ từng bản ghi kết quả tới sự kết hợp của DTO, managed entities, hoặc scalar values.
- Sử dụng `ResultTransformer` của Hibernate để ánh xạ từng bản ghi hoặc toàn bộ tập hợp kết quả thành DTO, managed entities, hoặc scalar values.

<br />

### 2.1. The entity mapping

Chúng ta cần chọn tất cả các cột của bảng trong database khớp với số lượng thuộc tính được ánh xạ trong entity class.

Tiếp theo, chúng ta cần cung cấp entity class sẽ ánh xạ kết quả của câu truy vấn. Đối với truy vấn native query, chúng ta có thể thực hiện điều đó bằng cách cung cấp tham chiếu lớp làm tham số cho phương thức `createNativeQuery()`. 

```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    User user = session.createNativeQuery("SELECT * FROM [User] WHERE user_id = ?", User.class)
            .setParameter(1, 1)
            .uniqueResult();
    System.out.println(user);

    transaction.commit();
}
```

Output
```java
User(userId=1, username=AnhDT, password=12345678, createdAt=2024-04-12 02:26:59.66, modifiedAt=2024-04-12 02:26:59.66)
```

<br />

Chúng ta cũng có thể thực hiện tương tự khi sử dụng `@NamedNativeQuery` bằng cách tham chiếu lớp thực thể dưới dạng thuộc tính `resultClass` của `@NamedNativeQuery`.

```java
@NamedNativeQuery(name = "selectUser", 
                  query = "SELECT * FROM [User] WHERE user_id = ?", 
                  resultClass = User.class)
@Entity
public class User { ... }
```

<br />

### 2.2. JPA’s `@SqlResultSetMapping`

Chúng ta có thể sử dụng DTO để lưu trữ các scalar values thu được, trước hết chúng ta cần tạo đối tượng `UserDTO` để lưu trữ `username` và `password` như sau:

__UserDTO.java__
```java
package dto;

import lombok.Data;

@Data
public class UserDTO {

    private String username;
    private String password;
}
```

Sử dụng `@SqlResultSetMapping` annotation để mapping:
- `name` phải có một tên duy nhất. Chúng ta sẽ sử dụng nó trong mã của mình để tham chiếu.
- `@ConstructorResult` yêu cầu Hibernate gọi hàm tạo của lớp `UserDTO` và cung cấp các trường `username` và `password` của tập kết quả làm tham số. Điều này cho phép chúng ta khởi tạo các đối tượng DTO không được quản lý, rất phù hợp cho các hoạt động __read only__. 
  - `targetClass`: Lớp POJO được ánh xạ.
  - `columns`: Mảng các `@ColumnResult` định nghĩa cách ánh xạ - các cột đến các tham số của trình tạo.
    - `name`: Tên cột trong kết quả truy vấn.

__User.java__
```java
@SqlResultSetMapping(
    name = "UsernameAndPasswordDTO",
    classes = @ConstructorResult(
        targetClass = UserDTO.class,
        columns = {
            @ColumnResult(name = "username"),
            @ColumnResult(name = "password")
        }
    )
)
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

Sau khi xác định ánh xạ, bạn có thể cung cấp tên của nó làm tham số thứ __2__ cho phương thức `createNativeQuery(String var1, String var2, Class<R> var3)` như sau:
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<UserDTO> users = session.createNativeQuery(
            "SELECT username, password FROM [User]",
            "UsernameAndPasswordDTO",
            UserDTO.class
    ).getResultList();

    for (UserDTO u : users) {
        System.out.println(u);
    }

    transaction.commit();
}
```

Output
```java
UserDTO(username=AnhDT, password=12345678)
UserDTO(username=MinhTH, password=12345678)
UserDTO(username=HoaTTH, password=12345678)
```

<br />

Chúng ta có thể mapping `@NamedNativeQuery` và `@SqlResultSetMapping` annotation trong entity như sau:

__User.java__
```java
@NamedNativeQuery(
    name="FindUserByUsernameAndPassword",
    query="SELECT username, password FROM [user]",
    resultSetMapping = "UsernameAndPasswordDTO"
)
@SqlResultSetMapping(
    name = "UsernameAndPasswordDTO",
    classes = @ConstructorResult(
        targetClass = UserDTO.class,
        columns = {
            @ColumnResult(name = "username"),
            @ColumnResult(name = "password")
        }
    )
)
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

Lúc này chúng ta có thể sử dụng tên đã đặt cho câu native query thông qua phương thức `createNamedQuery()` như sau:
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<UserDTO> users = session.createNamedQuery("FindUserByUsernameAndPassword", UserDTO.class)
            .getResultList();
    for (UserDTO u : users) {
        System.out.println(u);
    }

    transaction.commit();
}
```

<br />

### 2.3. Hibernate-specific `ResultTransformer`

<br />

## 3. Result handling

<br />

