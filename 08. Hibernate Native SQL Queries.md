# Hibernate Native SQL Queries

<br />

Trong Hibernate, HQL hoặc Criteria Query cho phép chúng ta thực hiện hầu hết mọi truy vấn SQL mong muốn. Tuy nhiên, đôi khi về câu lệnh SQL được tạo ra bởi Hibernate chậm hoặc cần viết câu lệnh phức tạp và thích tạo câu lệnh SQL (SQL gốc) của riêng mình hơn. Với Hibernate cho chúng ta sử dụng Native SQL để thao tác với cơ sở dữ liệu, bao gồm các stored procedures, và tất cả các thao tác create, update, delete và select.

Bảng dữ liệu demo sẽ sử dụng trong bài:
<table>
  <thead>
    <tr>
      <th width="112px">user_id</th>
      <th width="150px">username</th>
      <th width="150px">password</th>
      <th width="300px">created_at</th>
      <th width="300px">modified_at</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">1</td>
      <td align="right">AnhDT</td>
      <td align="right">12345678</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
    </tr>
    <tr>
      <td align="center">2</td>
      <td align="right">MinhTH</td>
      <td align="right">12345678</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
    </tr>
    <tr>
      <td align="center">3</td>
      <td align="right">HoaTTH</td>
      <td align="right">12345678</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
      <td align="right">2024-04-12 02:26:59.660000</td>
    </tr>
  </tbody>
</table>

<br />

## 1. Defining and executing a native query

Việc thực thi các truy vấn SQL gốc được kiểm soát thông qua `NativeQuery` interface, interface này có được bằng cách gọi `Session.createNativeQuery()`.

<br />

### 1.1. Scalar queries

Truy vấn SQL cơ bản nhất là lấy danh sách các giá trị vô hướng (column) từ một hoặc nhiều bảng.

Ví dụ lấy tất cả __column__ từ bảng __User__
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<Object[]> users = session.createNativeQuery("SELECT * FROM [User]", Object[].class).getResultList();
    for (Object[] u : users) {
        System.out.println(Arrays.toString(u));
    }

    transaction.commit();
}
```

Chúng ta có thể sử dụng phương thức `list()` để nhận về kết quả tương tự như `getResultList()`.

Output
```java
[1, AnhDT, 12345678, 2024-04-12 02:26:59.66, 2024-04-12 02:26:59.66]
[2, MinhTH, 12345678, 2024-04-12 02:26:59.66, 2024-04-12 02:26:59.66]
[3, HoaTTH, 12345678, 2024-04-12 02:26:59.66, 2024-04-12 02:26:59.66]
```

SQL
```sql
[Hibernate] SELECT * FROM [User]
```

<br />

Ví dụ chỉ lấy column `username` và `password` từ bảng __User__
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<Object[]> users = session.createNativeQuery("SELECT username, password FROM [User]", Object[].class)
            .getResultList();
    for (Object[] u : users) {
        System.out.println(Arrays.toString(u));
    }

    transaction.commit();
}
```

Output
```java
[AnhDT, 12345678]
[MinhTH, 12345678]
[HoaTTH, 12345678]
```

SQL
```sql
[Hibernate] SELECT username, password FROM [User]
```

<br />

### 1.2. Create named native queries

Chúng ta có thể sử dụng `@NamedNativeQuery()` annotation để đặt tên cho câu native query.

__User.java__
```java
@NamedNativeQuery(
    name="FindUsers",
    query="SELECT * FROM [user]"
)
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

Sử dụng tên đã đặt cho câu native query thông qua phương thức `createNamedQuery()` như sau:
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<Object[]> users = session.createNamedQuery("FindUsers", Object[].class).getResultList();
    for (Object[] u : users) {
        System.out.println(Arrays.toString(u));
    }

    transaction.commit();
}
```

<br />

Từ JPA 2.2 và Hibernate 5, chúng ta có thể lặp lại `@NamedNativeQuery` annotation để đặt tên cho nhiều câu native query.
```java
@NamedNativeQuery(
    name="FindUsers",
    query="SELECT * FROM [user]"
)
@NamedNativeQuery(
    name="FindUserByUsernameAndPassword",
    query="SELECT username, password FROM [user]"
)
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

Nếu bạn đang sử dụng phiên bản JPA hoặc Hibernate cũ hơn, bạn cần phải khai báo nó bên trong `@NamedNativeQueries` annotation.
```java
@NamedNativeQueries({
    @NamedNativeQuery(
        name="FindUsers",
        query="SELECT * FROM [user]"
    ),
    @NamedNativeQuery(
        name="FindUserByUsernameAndPassword",
        query="SELECT username, password FROM [user]"
    )
})
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

<br />

### 1.3. Parameter binding

Chúng ta có thể và nên sử dụng các liên kết tham số cho các tham số truy vấn của câu native query thay vì đặt các giá trị trực tiếp vào query String.

Giống như trong JDBC, chúng ta có thể sử dụng ký tự `?` để tham chiếu đến vị trí các tham số trong câu native query và việc đánh số của chúng bắt đầu từ __1__. 
```java
SELECT * FROM [User] WHERE user_id = ?
```

Sau đó chúng ta cần sử dụng phương thức `setParameter(int var1, Object var2)` để gán giá trị cho các tham số trong câu query.
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    NativeQuery<Object> query = session.createNativeQuery("SELECT * FROM [User] WHERE user_id = ?", Object.class);
    Object[] objects = (Object[]) query.setParameter(1, 1).uniqueResult();
    System.out.println(Arrays.toString(objects));

    transaction.commit();
}
```

<br />

Hibernate cũng hỗ trợ các liên kết tham số được đặt tên cho các native queries, điều này không được xác định bởi đặc tả và có thể không khả dụng đối với các triển khai JPA khác.

Bằng cách sử dụng các liên kết tham số được đặt tên, bạn xác định tên cho từng tham số và cung cấp tên đó cho phương thức `setParameter(String var1, Object var2)` để liên kết một giá trị với tham số đó. Tên có phân biệt chữ hoa chữ thường và bạn cần thêm ký hiệu `:` làm tiền tố.

Ví dụ
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    NativeQuery<Object> query = session.createNativeQuery("SELECT * FROM [User] WHERE user_id = :id", Object.class);
    Object[] objects = (Object[]) query.setParameter("id", 1).uniqueResult();
    System.out.println(Arrays.toString(objects));

    transaction.commit();
}
```

Output
```java
[1, AnhDT, 12345678, 2024-04-12 02:26:59.66, 2024-04-12 02:26:59.66]
```

SQL
```sql
[Hibernate] SELECT * FROM [User] WHERE user_id = ?
```

<br />

## 2. Result handling

Như bạn đã thấy trong các đoạn mã trước, truy vấn gốc của bạn trả về __Object[]__ hoặc __List of Object[]__. Nếu bạn muốn truy xuất kết quả truy vấn của mình dưới dạng cấu trúc dữ liệu khác, bạn cần cung cấp thêm thông tin ánh xạ. Có 2 lựa chọn thường được sử dụng:

- Ánh xạ từng bản ghi trong kết quả truy vấn tới managed entity bằng cách sử dụng entity’s mapping.
- Sử dụng chú thích `@SqlResultSetMapping` của JPA để ánh xạ từng bản ghi kết quả tới sự kết hợp của DTO, managed entities, hoặc scalar values.

<br />

### 2.1. The entity mapping

Truy vấn cần trả về tất cả các cột của bảng trong database khớp với số lượng thuộc tính được ánh xạ trong entity class.

Tiếp theo, chúng ta cần cung cấp entity class sẽ ánh xạ kết quả của câu truy vấn. Đối với truy vấn native query, chúng ta có thể thực hiện điều đó bằng cách cung cấp tham chiếu lớp làm tham số cho phương thức `createNativeQuery()`. 

```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    User user = session.createNativeQuery("SELECT * FROM [User] WHERE user_id = ?", User.class)
            .setParameter(1, 1)
            .uniqueResult();
    System.out.println(user);

    transaction.commit();
}
```

Output
```java
User(userId=1, username=AnhDT, password=12345678, createdAt=2024-04-12 02:26:59.66, modifiedAt=2024-04-12 02:26:59.66)
```

<br />

### 2.2. JPA’s `@SqlResultSetMapping`

Chúng ta có thể sử dụng DTO để lưu trữ các scalar values thu được, trước hết chúng ta cần tạo đối tượng `UserDTO` để lưu trữ `username` và `password` như sau:

__UserDTO.java__
```java
package dto;

import lombok.Data;

@Data
public class UserDTO {

    private String username;
    private String password;
}
```

Sử dụng `@SqlResultSetMapping` annotation để mapping:
- `name` phải có một tên duy nhất. Chúng ta sẽ sử dụng nó trong mã của mình để tham chiếu.
- `@ConstructorResult` yêu cầu Hibernate gọi hàm tạo của lớp `UserDTO` và cung cấp các trường `username` và `password` của tập kết quả làm tham số. Điều này cho phép chúng ta khởi tạo các đối tượng DTO không được quản lý, rất phù hợp cho các hoạt động __read only__. 
  - `targetClass`: Lớp POJO được ánh xạ.
  - `columns`: Mảng các `@ColumnResult` định nghĩa cách ánh xạ - các cột đến các tham số của trình tạo.
    - `name`: Tên cột trong kết quả truy vấn.

__User.java__
```java
@SqlResultSetMapping(
    name = "UsernameAndPasswordDTO",
    classes = @ConstructorResult(
        targetClass = UserDTO.class,
        columns = {
            @ColumnResult(name = "username"),
            @ColumnResult(name = "password")
        }
    )
)
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

Sau khi xác định ánh xạ, bạn có thể cung cấp tên của nó làm tham số thứ __2__ cho phương thức `createNativeQuery(String var1, String var2, Class<R> var3)` để thực hiện truy vấn như sau:
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<UserDTO> users = session.createNativeQuery(
            "SELECT username, password FROM [User]",
            "UsernameAndPasswordDTO",
            UserDTO.class
    ).getResultList();

    for (UserDTO u : users) {
        System.out.println(u);
    }

    transaction.commit();
}
```

Output
```java
UserDTO(username=AnhDT, password=12345678)
UserDTO(username=MinhTH, password=12345678)
UserDTO(username=HoaTTH, password=12345678)
```

<br />

Chúng ta cũng có thể mapping `@NamedNativeQuery` và `@SqlResultSetMapping` annotation trong entity như sau:

__User.java__
```java
@NamedNativeQuery(
    name="FindUserByUsernameAndPassword",
    query="SELECT username, password FROM [user]",
    resultSetMapping = "UsernameAndPasswordDTO"
)
@SqlResultSetMapping(
    name = "UsernameAndPasswordDTO",
    classes = @ConstructorResult(
        targetClass = UserDTO.class,
        columns = {
            @ColumnResult(name = "username"),
            @ColumnResult(name = "password")
        }
    )
)
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

Lúc này chúng ta có thể sử dụng tên đã đặt cho câu native query thông qua phương thức `createNamedQuery()` như sau:
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<UserDTO> users = session.createNamedQuery("FindUserByUsernameAndPassword", UserDTO.class)
            .getResultList();
    for (UserDTO u : users) {
        System.out.println(u);
    }

    transaction.commit();
}
```

<br />

### 2.2.1. Default mapping

Cách dễ nhất để ánh xạ kết quả truy vấn tới một entity là cung cấp lớp entity làm tham số cho phương thức `createNativeQuery(String sqlString, Class resultClass)` của __EntityManager__ và sử dụng ánh xạ mặc định.

Các bạn có thể xem lại phần này ở mục [2.1. The entity mapping](https://github.com/AnestStudio/Hibernate/blob/main/08.%20Hibernate%20Native%20SQL%20Queries.md#21-the-entity-mapping)

<br />

### 2.2.2. Custom mapping

Mặc dù việc ánh xạ tự động rất hữu ích và dễ xác định nhưng nó thường không đáp ứng đủ tất cả trường hợp. Nếu chúng ta thực hiện một truy vấn phức tạp hơn hoặc gọi một stored procedure, tên của các cột được trả về có thể không khớp với thuộc tính của thực thể. Trong trường hợp này, chúng ta cần xác định ánh xạ kết quả tùy chỉnh.

Hãy xem ví dụ sau, chúng ta sẽ thay đổi truy vấn đã sử dụng trước đó và đổi tên cột:
- `user_id => id`
- `username => account`
  
```sql
SELECT
    u.user_id as id,
    u.username as account,
    u.password,
    u.created_at,
    u.modified_at
FROM [user] u
```

Ánh xạ mặc định tới __User__ entity sẽ không hoạt động với kết quả truy vấn này vì tên của các cột đã chọn và thuộc tính của __User__ không khớp. Chúng ta cần ánh xạ tùy chỉnh trong trường hợp này.

__User.java__
```java
@NamedNativeQuery(
    name="SelectUsersCustomMapping",
    query="SELECT u.user_id as id, u.username as account, u.password, u.created_at, u.modified_at FROM [user] u",
    resultSetMapping = "UserCustomMapping"
)
@SqlResultSetMapping(
    name = "UserCustomMapping",
    entities = @EntityResult(
        entityClass = User.class,
        fields = {
            @FieldResult(name = "userId", column = "id"),
            @FieldResult(name = "username", column = "account"),
            @FieldResult(name = "password", column = "password"),
            @FieldResult(name = "createdAt", column = "created_at"),
            @FieldResult(name = "modifiedAt", column = "modified_at")
        }
    )
)
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

Output
```java
User(userId=1, username=AnhDT, password=12345678, createdAt=2024-04-12 02:26:59.66, modifiedAt=2024-04-12 02:26:59.66)
User(userId=2, username=MinhTH, password=12345678, createdAt=2024-04-12 02:26:59.66, modifiedAt=2024-04-12 02:26:59.66)
User(userId=3, username=HoaTTH, password=12345678, createdAt=2024-04-12 02:26:59.66, modifiedAt=2024-04-12 02:26:59.66)
```

SQL
```java
[Hibernate] SELECT u.user_id as id, u.username as account, u.password, u.created_at, u.modified_at FROM [user] u
```

<br />

### 2.2.3. Complex Mappings

Trước khi đi sâu vào các ánh xạ phức tạp, chúng ta sẽ tạo thêm đối tượng `UserDetail` sẽ sử dụng cho các ví dụ. Như vậy chúng ta sẽ có 2 đối tượng là `User` và `UserDetail`. Để đơn giản, mỗi `User` sẽ chỉ có một thông tin `UserDetail`.

<br />

<p align="center">
  <img src="https://github.com/AnestStudio/Hibernate/blob/main/images/user__user_detail.png">
</p>

<br />

### 2.2.3.1. Mapping multiple entities

Chúng ta sẽ lấy danh sách thông tin của __User__ và __UserDetail__ như sau:
```sql
SELECT
    u.user_id, u.username, u.password, u.created_at, u.modified_at,
    ud.user_detail_id, ud.first_name, ud.last_name, ud.gender, ud.bod, ud.mobile, ud.email, ud.user_id as fk_user_id
FROM [user] u
JOIN user_detail ud
    on u.user_id = ud.user_id
```

Như trong ví dụ trước đó, `@SqlResultSetMapping` xác định tên của ánh xạ mà chúng ta sẽ sử dụng để tham chiếu. Sự khác biệt chính ở đây là chúng ta 
sẽ cung cấp hai chú thích `@EntityResult`, một cho `User` và một cho `UserDetail`.
```java
@NamedNativeQuery(
    name = "FindUserWithDetailInfoById",
    query =
        "SELECT\n" +
        "    u.user_id, u.username, u.password, u.created_at, u.modified_at,\n" +
        "    ud.user_detail_id, ud.first_name, ud.last_name, ud.gender, ud.bod, ud.mobile, ud.email, ud.user_id as fk_user_id\n" +
        "FROM [user] u\n" +
        "JOIN user_detail ud\n" +
        "    on u.user_id = ud.user_id",
    resultSetMapping = "UserWithDetailInfo"
)
@SqlResultSetMapping(
    name = "UserWithDetailInfo",
    entities = {
        @EntityResult(
            entityClass = User.class,
            fields = {
                @FieldResult( name = "userId", column = "user_id" ),
                @FieldResult( name = "username", column = "username" ),
                @FieldResult( name = "password", column = "password" ),
                @FieldResult( name = "createdAt", column = "created_at" ),
                @FieldResult( name = "modifiedAt", column = "modified_at" )
            }
        ),
        @EntityResult(
            entityClass = UserDetail.class,
            fields = {
                @FieldResult( name = "userDetailId", column = "user_detail_id" ),
                @FieldResult( name = "firstName", column = "first_name" ),
                @FieldResult( name = "lastName", column = "last_name" ),
                @FieldResult( name = "gender", column = "gender" ),
                @FieldResult( name = "bod", column = "bod" ),
                @FieldResult( name = "mobile", column = "mobile" ),
                @FieldResult( name = "email", column = "email" ),
                @FieldResult( name = "user", column = "fk_user_id" )
            }
        )
    }
)
@Data
@Entity
@Table(name = "[user]")
public class User { ... }
```

Chúng ta sử dụng tên đã đặt cho câu native query để thực hiện truy vấn như sau:
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    List<Object[]> results = session.createNamedQuery("FindUserWithDetailInfoById", Object[].class).getResultList();
    results.forEach(record -> {
        User u = (User) record[0];
        UserDetail ud = (UserDetail) record[1];
        // do something
    });

    transaction.commit();
}
```

<br />

### 2.2.3.2. Mapping additional columns

<br />

