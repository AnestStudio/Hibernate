# Hibernate Native SQL Queries

<br />

Trong Hibernate, HQL hoặc Criteria Query cho phép chúng ta thực hiện hầu hết mọi truy vấn SQL mong muốn. Tuy nhiên, đôi khi về câu lệnh SQL được tạo ra bởi Hibernate chậm hoặc cần viết câu lệnh phức tạp và thích tạo câu lệnh SQL (SQL gốc) của riêng mình hơn. Với Hibernate cho chúng ta sử dụng Native SQL để thao tác với cơ sở dữ liệu, bao gồm các stored procedures, và tất cả các thao tác create, update, delete và select.

Bảng dữ liệu demo sẽ sử dụng trong bài:
<table>
  <thead>
    <tr>
      <th width="112px">user_id</th>
      <th width="150px">username</th>
      <th width="150px">password</th>
      <th width="300px">created_at</th>
      <th width="300px">modified_at</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center">1</td>
      <td align="right">AnhDT</td>
      <td align="right">12345678</td>
      <td align="right">2024-04-11 21:30:22.316000</td>
      <td align="right">2024-04-11 21:30:22.316000</td>
    </tr>
    <tr>
      <td align="center">2</td>
      <td align="right">MinhTH</td>
      <td align="right">12345678</td>
      <td align="right">2024-04-11 21:30:22.316000</td>
      <td align="right">2024-04-11 21:30:22.316000</td>
    </tr>
    <tr>
      <td align="center">3</td>
      <td align="right">HoaTTH</td>
      <td align="right">12345678</td>
      <td align="right">2024-04-11 21:30:22.316000</td>
      <td align="right">2024-04-11 21:30:22.316000</td>
    </tr>
  </tbody>
</table>

<br />

## 1. Defining and executing a native query

### 1.1. Create native queries

Truy vấn SQL cơ bản nhất là để có được một danh sách các giá trị __column__ từ một hoặc nhiều bảng. Để tạo đối tượng Native Query chúng ta sẽ sử dụng phương thức `createNativeQuery()` từ đối tượng __Session__.

Ví dụ lấy tất cả __column__ từ bảng __User__
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    NativeQuery<Object> query = session.createNativeQuery("SELECT * FROM [User] WHERE user_id = ?", Object.class);
    Object[] objects = (Object[]) query.setParameter(1, 1).uniqueResult();
    System.out.println(Arrays.toString(objects));

    transaction.commit();
}
```

Output
```java
[1, AnhDT, 12345678, 2024-04-11 21:30:22.316, 2024-04-11 21:30:22.316]
```

SQL
```sql
[Hibernate] SELECT * FROM [User] WHERE user_id = ?
```

<br />

Ví dụ chỉ lấy column `username` và `password` từ bảng __User__
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    NativeQuery<Object> query = session.createNativeQuery(
        "SELECT username, password FROM [User] WHERE user_id = ?", 
        Object.class
    );
    Object[] objects = (Object[]) query.setParameter(1, 1).uniqueResult();
    System.out.println(Arrays.toString(objects));

    transaction.commit();
}
```

Output
```java
[AnhDT, 12345678]
```

SQL
```sql
[Hibernate] SELECT username, password FROM [User] WHERE user_id = ?
```

<br />

### 1.2. Create named native queries

<br />

### 1.3. Parameter binding

Chúng ta có thể và nên sử dụng các liên kết tham số cho các tham số truy vấn của câu native query thay vì đặt các giá trị trực tiếp vào query String.

Giống như trong JDBC, chúng ta có thể sử dụng ký tự `?` để tham chiếu đến vị trí các tham số trong câu native query và việc đánh số của chúng bắt đầu từ __1__. Sau đó chúng ta cần sử dụng phương thức `setParameter()` để gán giá trị cho các tham số trong câu query.

Ví dụ
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    NativeQuery<Object> query = session.createNativeQuery("SELECT * FROM [User] WHERE user_id = ?", Object.class);
    Object[] objects = (Object[]) query.setParameter(1, 1).uniqueResult();
    System.out.println(Arrays.toString(objects));

    transaction.commit();
}
```

<br />

Hibernate cũng hỗ trợ các liên kết tham số được đặt tên cho các native queries, điều này không được xác định bởi đặc tả và có thể không khả dụng đối với các triển khai JPA khác.

Bằng cách sử dụng các liên kết tham số được đặt tên, bạn xác định tên cho từng tham số và cung cấp tên đó cho phương thức `setParameter()` để liên kết một giá trị với tham số đó. Tên có phân biệt chữ hoa chữ thường và bạn cần thêm ký hiệu `:` làm tiền tố.

Ví dụ lấy ra 
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    NativeQuery<Object> query = session.createNativeQuery("SELECT * FROM [User] WHERE user_id = :id", Object.class);
    Object[] objects = (Object[]) query.setParameter("id", 1).uniqueResult();
    System.out.println(Arrays.toString(objects));

    transaction.commit();
}
```

Output
```java
[1, AnhDT, 12345678, 2024-04-11 21:30:22.316, 2024-04-11 21:30:22.316]
```

SQL
```sql
[Hibernate] SELECT * FROM [User] WHERE user_id = ?
```

<br />

## 2. Result handling

Như bạn đã thấy trong các đoạn mã trước, truy vấn gốc của bạn trả về __Object[]__ hoặc __List of Object[]__. Nếu bạn muốn truy xuất kết quả truy vấn của mình dưới dạng cấu trúc dữ liệu khác, bạn cần cung cấp thêm thông tin ánh xạ. Có 3 lựa chọn thường được sử dụng:

- Ánh xạ từng bản ghi trong kết quả truy vấn tới managed entity bằng cách sử dụng entity’s mapping.
- Sử dụng chú thích `@SqlResultSetMapping` của JPA để ánh xạ từng bản ghi kết quả tới sự kết hợp của DTO, managed entities, hoặc scalar values.
- Sử dụng `ResultTransformer` của Hibernate để ánh xạ từng bản ghi hoặc toàn bộ tập hợp kết quả thành DTO, managed entities, hoặc scalar values.

<br />

### 2.1. The entity mapping

Chúng ta cần chọn tất cả các cột của bảng trong database khớp với số lượng thuộc tính được ánh xạ trong entity class.

Tiếp theo, chúng ta cần cung cấp entity class sẽ ánh xạ kết quả của câu truy vấn. Đối với truy vấn native query, chúng ta có thể thực hiện điều đó bằng cách cung cấp tham chiếu lớp làm tham số cho phương thức `createNativeQuery()`. 

```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    NativeQuery<User> query = session.createNativeQuery("SELECT * FROM [User] WHERE user_id = ?", User.class);
    query.setParameter(1, 1);
    User user = query.uniqueResult();
    System.out.println(user);

    transaction.commit();
}
```

Output
```java
User(userId=1, username=AnhDT, password=12345678, createdAt=2024-04-12 02:26:59.66, modifiedAt=2024-04-12 02:26:59.66)
```

<br />

Chúng ta cũng có thể thực hiện tương tự khi sử dụng `@NamedNativeQuery` bằng cách tham chiếu lớp thực thể dưới dạng thuộc tính `resultClass` của `@NamedNativeQuery`.

```java
@NamedNativeQuery(name = "selectUser", 
                  query = "SELECT * FROM [User] WHERE user_id = ?", 
                  resultClass = User.class)
@Entity
public class User { ... }
```

<br />

### 2.2. JPA’s `@SqlResultSetMapping`

<br />

### 2.3. Hibernate-specific `ResultTransformer`


<br />

