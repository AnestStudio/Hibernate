# Association Mappings

<br />

Một __liên kết (association)__ là một mối quan hệ giữa các thực thể. Chúng ta phân loại các liên kết dựa trên tính chất - đặc điểm của chúng. Nếu `E` và `F` đều là các lớp thực thể thì:
- __one-to-one__: 1 thể hiện duy nhất của `E` liên kết với 1 thể hiện duy nhất của `F`.
- __many-to-one__: 0 hoặc nhiều thể hiện của `E` liên kết với 1 thể hiện duy nhất của `F`.
- __many-to-many__: 0 hoặc nhiều thể hiện của `E` liên kết với 1 hoặc nhiều thể hiện của `F`.

Một liên kết giữa các lớp thực thể có thể là:
- __một chiều (unidirectional)__: có thể điều hướng từ `E` đến `F` nhưng không thể từ `F` tới `E`.
- __hai chiều (bidirectional)__: có thể điều hướng theo một trong hai hướng.

_Không phải tất cả các mối quan hệ đều là hai chiều. Một sai lầm phổ biến của người mới bắt đầu khi thiết kế mô hình thực thể là cố gắng tạo ra tất cả các liên kết hai chiều._

Có 3 chú thích cho các liên kết ánh xạ là: 
- @OneToOne
- @ManyToOne
- @ManyToMany
  
Chúng dùng chung một số thành phần chú thích như sau:

| Member | Interpretation |	Default value |
| ------ | -------------- | ------------- |
| _cascade_      | - | { } |
| _fetch_        | - | - __LAZY__ cho `@OneToMany` và `@ManyToMany` <br /> - __EAGER__ cho `@ManyToOne` |
| _targetEntity_ | Lớp thực thể liên quan | Xác định từ khai báo kiểu thuộc tính |
| _optional_     | Đối với liên kết `@ManyToOne` hoặc `@OneToOne`, liên kết có thể `null` hay không | `true` |
| _mappedBy_     | Đối với một liên kết hai chiều, một thuộc tính của thực thể liên kết sẽ ánh xạ liên kết đó | Theo mặc định, liên kết được coi là một chiều |

Chúng ta sẽ giải thích chi tiết tác dụng của các thành phần này khi chúng ta xem xét các loại ánh xạ liên kết khác nhau.

<br />

## 1. `many-to-one`

<br />

## 2. `one-to-one` (first way)

Giả sử chúng ta sẽ có 2 đối tượng là `User` và `UserDetail`, một đối tượng `User` sẽ chỉ có tương ứng một thông tin `UserDetail` trong cơ sở dữ liệu.

<p align="center">
  <img src="https://github.com/AnestStudio/Hibernate/blob/main/images/user__user_detail.png">
</p>

Mối liên kết one-to-one phải được chú thích bằng annotation `@OneToOne` như sau:

__UserDetail.java__
```java
@Getter
@Setter
@Entity
@Table(name = "user_detail")
public class UserDetail {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_detail_id")
    private Long userDetailId;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    @Column
    private String gender;

    @Column
    private String bod;

    @Column
    private String mobile;

    @Column
    private String email;

    @OneToOne
    @JoinColumn(name = "user_id", referencedColumnName = "user_id")
    private User user;
}
```

Ở đây, bảng `user_detail` sẽ có một cột khóa ngoại chứa mã định danh của `user` là `user_id`.

Mặc định Hibernate sẽ generate tên của khóa ngoại dựa trên tên của thuộc tính và primary key của bảng được tham chiếu, ở đây là bảng `user`. Chúng ta sử dụng `@JoinColumn` để thay đổi giá trị mặc định này theo ý muốn.

Class `User` chúng ta tạo bình thường như sau:

__User.java__
```java
@Getter
@Setter
@Entity
@Table(name = "[user]")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long userId;

    @Column
    private String username;

    @Column
    private String password;

    @Column(name = "created_at")
    @Temporal(value = TemporalType.TIMESTAMP)
    private Date createdAt;

    @Column(name = "modified_at")
    @Temporal(value = TemporalType.TIMESTAMP)
    private Date modifiedAt;
}
```


Lúc này, chúng ta thử lấy ra thông tin của `UserDetail` như sau:
```java
try (Session session = HibernateUtil.getSessionFactory().openSession()) {
    Transaction transaction = session.beginTransaction();

    UserDetail ud = session.get(UserDetail.class, 1);
    System.out.println(
            ud.getUserDetailId() + " - " +
            ud.getFirstName() + " " + ud.getLastName()
    );
    System.out.println(
            ud.getUser().getUserId() + " - " +
            ud.getUser().getUsername()
    );

    transaction.commit();
}
```

Output
```java
1 - Tuấn Anh
1 - AnhDT
```

SQL
```sql
[Hibernate] 
    select
        ud1_0.user_detail_id,
        ud1_0.bod,
        ud1_0.email,
        ud1_0.first_name,
        ud1_0.gender,
        ud1_0.last_name,
        ud1_0.mobile,
        u1_0.user_id,
        u1_0.created_at,
        u1_0.modified_at,
        u1_0.password,
        u1_0.username 
    from
        user_detail ud1_0 
    left join
        [user] u1_0 
            on u1_0.user_id=ud1_0.user_id 
    where
        ud1_0.user_detail_id=?
```
Chúng ta có thể thấy, ngoài thông tin của `UserDetail` thì chúng ta cũng lấy được luôn đầy đủ thông tin của `User` đi kèm.

<br />

Chúng ta có thể tạo __liên kết hai chiều__ bằng cách thêm một tham chiếu ngược lại `User.userDetail` trong class `User`.

__User.java__
```java
@Getter
@Setter
@Entity
@Table(name = "[user]")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long userId;

    @Column
    private String username;

    @Column
    private String password;

    @Column(name = "created_at")
    @Temporal(value = TemporalType.TIMESTAMP)
    private Date createdAt;

    @Column(name = "modified_at")
    @Temporal(value = TemporalType.TIMESTAMP)
    private Date modifiedAt;

    @OneToOne(mappedBy = "user")
    private UserDetail userDetail;
}
```

Trong mối liên kết hai chiều, một trong các bên (và chỉ một) phải là chủ sở hữu. Chủ sở hữu chịu trách nhiệm cập nhật (các) cột liên kết. Để tuyên bố bên nào không chịu trách nhiệm về mối liên kết quan hệ, thuộc tính `mappedBy` được sử dụng. `mappedBy` liên kết đến tên của thuộc tính liên kết về phía chủ sở hữu.

Như trong ví dụ trên `mappedBy = "user"` liên kết đến thuộc tính `user` trong class `UserDetail`. Ở đây, chúng ta có thể xem `UserDetail` là chủ sở hữu của liên kết giữa `User` và `UserDetail` vì trong bảng `user_detail` chứa khóa phụ liên kết đến bảng `user`.

<br />

## 3. `one-to-one` (second way)

<br />

## 4. `many-to-many`

<br />
